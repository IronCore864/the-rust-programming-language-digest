<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language Digest</a></li><li class="chapter-item expanded affix "><a href="0_introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="1_getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="2_guessing_game.html"><strong aria-hidden="true">2.</strong> Guessing Game</a></li><li class="chapter-item expanded "><a href="3_common_concepts.html"><strong aria-hidden="true">3.</strong> Common Concepts</a></li><li class="chapter-item expanded "><a href="4_ownership.html"><strong aria-hidden="true">4.</strong> Ownership</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-rust-programming-language"><a class="header" href="#the-rust-programming-language">The Rust Programming Language</a></h1>
<p>The digest for the <a href="https://doc.rust-lang.org/book/title-page.html">Rust book</a>.</p>
<p>For readers who don't have deep understanding of another programming language but want to learn Rust, it's highly recommended to read the original book. It's much more verbose but also much more in detail.</p>
<p>For experienced programmars who are already quite famliar with at least one language, reading this digest might work for you to get started with Rust quickly.</p>
<p>This digest also works as a &quot;cheat sheet&quot; if you forget something but want to do a quick search.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="0-introduction"><a class="header" href="#0-introduction">0. Introduction</a></h1>
<p>Rust usage examples:</p>
<ul>
<li>command line tools</li>
<li>web services</li>
<li>DevOps tooling</li>
<li>embedded devices</li>
<li>audio and video analysis and transcoding</li>
<li>cryptocurrencies</li>
<li>bioinformatics</li>
<li>search engines</li>
<li>Internet of Things applications</li>
<li>machine learning</li>
<li>major parts of the Firefox web browser.</li>
</ul>
<p>Rust is for people who crave <strong>speed and stability</strong> in a language. Speed: the speed of the programs that you can create with Rust and the speed at which Rust lets you write them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-getting-started"><a class="header" href="#1-getting-started">1. Getting Started</a></h1>
<h2 id="11-install"><a class="header" href="#11-install">1.1 Install</a></h2>
<p><code>rustup</code>: a command line tool for managing Rust versions and associated tools.</p>
<pre><code class="language-bash">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh

# A C compiler is required
# because some common Rust packages depend on C code and will need a C compiler.
# On macOS, you can get a C compiler by running:
xcode-select --install
</code></pre>
<p>Update:</p>
<pre><code class="language-bash">$ rustup update
</code></pre>
<p>Uninstall:</p>
<pre><code class="language-bash">rustup self uninstall
</code></pre>
<p>Version check:</p>
<pre><code class="language-bash">rustc --version
</code></pre>
<h2 id="12-write-compile-and-run"><a class="header" href="#12-write-compile-and-run">1.2 Write, Compile and Run</a></h2>
<pre><code class="language-bash">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
$ touch main.rs
</code></pre>
<p><strong>Rust files always end with the <em>.rs</em> extension. If you’re using more than one word in your filename, use an underscore to separate them. For example, use <em>hello_world.rs</em> rather than<em>helloworld.rs</em>.</strong></p>
<p>Now open the <em>main.rs</em> file you just created and enter the code in Listing 1-1.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<ul>
<li><code>fn</code></li>
<li>println! calls a Rust macro. If it called a function instead, it would be entered as println (without the !)</li>
<li>semicolon</li>
</ul>
<h2 id="13-cargo"><a class="header" href="#13-cargo">1.3 Cargo</a></h2>
<p>Check cargo's version:</p>
<pre><code class="language-bash">cargo --version
</code></pre>
<p>Create a project with cargo:</p>
<pre><code class="language-bash">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>Build and run:</p>
<pre><code class="language-bash">cargo build
cargo run
</code></pre>
<p>Cargo also provides a command called <strong>cargo check</strong>. This command quickly checks your code to make sure it compiles but doesn’t produce an executable:</p>
<pre><code class="language-bash">cargo check
</code></pre>
<p>When your project is finally ready for release, you can use <strong>cargo build --release</strong> to compile it with optimizations.</p>
<p>This command will create an executable in <code>target/release</code> instead of <code>target/debug</code>. The optimizations make your Rust code run faster, but turning them on lengthens the time it takes for your program to compile. This is why there are two different profiles: one for development, when you want to rebuild quickly and often, and another for building the final program you’ll give to a user that won’t be rebuilt repeatedly and that will run as fast as possible. <strong>If you're benchmarking your code's running time, be sure to run cargo build --release and benchmark with the executable in target/release.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-guessing-game"><a class="header" href="#2-guessing-game">2. Guessing Game</a></h1>
<h2 id="21-bring-library-into-scope"><a class="header" href="#21-bring-library-into-scope">2.1 Bring Library into Scope</a></h2>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<h2 id="22-mutable-vs-immutable"><a class="header" href="#22-mutable-vs-immutable">2.2 Mutable V.S. immutable</a></h2>
<pre><code class="language-rust ignore">let apples = 5; // immutable
let mut bananas = 5; // mutable
</code></pre>
<p>By default variables are immutable.</p>
<h2 id="23-read-input"><a class="header" href="#23-read-input">2.3 Read Input</a></h2>
<pre><code class="language-rust ignore">io::stdin()
    .read_line(&amp;mut guess)
    .expect(&quot;Failed to read line&quot;);
</code></pre>
<p>One long line is difficult to read, so it’s best to divide it.</p>
<p><code>read_line</code> returns a value, an <code>io::Result</code>. The Result types are enums. For Result, the variants are:</p>
<ul>
<li><code>Ok</code>: the operation was successful, and inside Ok is the successfully generated value;</li>
<li><code>Err</code>: the operation failed, and Err contains information about how or why the operation failed.</li>
</ul>
<p><code>expect</code>:</p>
<ul>
<li>if <code>io::Result</code> is an <code>Err</code> value, expect will cause the program to crash and display the message that you passed as an argument to expect;</li>
<li>if <code>io::Result</code> is an <code>Ok</code> value, expect will take the return value that Ok is holding and return just that value to you so you can use it.</li>
</ul>
<h2 id="24-line-print-with-placeholder"><a class="header" href="#24-line-print-with-placeholder">2.4 Line Print with Placeholder</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {} and y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<h2 id="25-adding-dependencies"><a class="header" href="#25-adding-dependencies">2.5 Adding Dependencies</a></h2>
<p>In <code>Cargo.toml</code> file, add:</p>
<pre><code class="language-rust ignore">rand = &quot;0.8.3&quot;
</code></pre>
<p>Here, SEMVER is used.</p>
<p>Update cargo:</p>
<pre><code class="language-bash">cargo update
</code></pre>
<h2 id="26-rng"><a class="header" href="#26-rng">2.6 RNG</a></h2>
<pre><code class="language-rust ignore">use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..101);
    println!(&quot;The secret number is: {}&quot;, secret_number);
}
</code></pre>
<h2 id="27-gen_range"><a class="header" href="#27-gen_range">2.7 <code>gen_range</code></a></h2>
<p>gen_range(start..end):</p>
<ul>
<li>inclusive on the lower bound</li>
<li>exclusive on the upper bound</li>
<li>range <code>1..101</code> is equivalent to <code>1..=100</code></li>
</ul>
<h2 id="28-match-expression"><a class="header" href="#28-match-expression">2.8 Match Expression</a></h2>
<p><code>std::cmp::Ordering</code> enum:</p>
<ul>
<li><code>Less</code></li>
<li><code>Greater</code></li>
<li><code>Equal</code></li>
</ul>
<p>A match expression is made up of arms:</p>
<pre><code class="language-rust ignore">match guess.cmp(&amp;secret_number) {
    Ordering::Less =&gt; println!(&quot;Too small!&quot;),
    Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
    Ordering::Equal =&gt; println!(&quot;You win!&quot;),
}
</code></pre>
<h2 id="29-trim--parse-handle-input"><a class="header" href="#29-trim--parse-handle-input">2.9 Trim &amp; Parse: Handle Input</a></h2>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</code></pre>
<p>The <code>trim</code> method eliminates <code>\n</code> or <code>\r\n</code>.</p>
<ul>
<li><code>parse</code> method on strings: parses a string into some kind of number</li>
<li>could easily cause an error</li>
<li>returns a <code>Result type</code>, needs to be handled</li>
</ul>
<h2 id="210-loop-and-break"><a class="header" href="#210-loop-and-break">2.10 Loop and Break</a></h2>
<pre><code class="language-rust ignore">    loop {
        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                break;
            }
        }
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-common-concepts"><a class="header" href="#3-common-concepts">3. Common Concepts</a></h1>
<h2 id="31-variables-and-mutability"><a class="header" href="#31-variables-and-mutability">3.1. Variables and Mutability</a></h2>
<h2 id="311-mutability"><a class="header" href="#311-mutability">3.1.1 Mutability</a></h2>
<p>By default, variables are immutable.</p>
<p>Error:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
}
</code></pre></pre>
<p>Make it mutable by adding mut in front of the variable name:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<h3 id="312-differences-between-variables-and-constants"><a class="header" href="#312-differences-between-variables-and-constants">3.1.2 Differences Between Variables and Constants</a></h3>
<ul>
<li>constants can't be mut</li>
<li>declaration: constants: <code>const</code> keyword</li>
<li>constants can be declared in any scope, including the global scope</li>
<li>constants may be set only to a constant expression, not the result of a function call or any other value that could only be computed at runtime</li>
</ul>
<p>Here’s an example of a constant declaration where the constant’s name is MAX_POINTS and its value is set to 100,000. (Rust’s naming convention for constants is to use all uppercase with underscores between words, and underscores can be inserted in numeric literals to improve readability):</p>
<h3 id="313-shadowing"><a class="header" href="#313-shadowing">3.1.3 Shadowing</a></h3>
<p>You can declare a new variable with the same name as a previous variable. The first variable is shadowed by the second.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let x = x + 1;
    let x = x * 2;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>Shadowing V.S. mut:</p>
<ul>
<li>reassign to this variable without using the let keyword will cause an error</li>
<li>we're effectively creating a new variable when we use the let keyword again, we can change the type of the value but reuse the same name. Mut can't change type.</li>
</ul>
<h2 id="32-data-types"><a class="header" href="#32-data-types">3.2. Data Types</a></h2>
<p>Rust is a statically typed language, which means that it must know the types of all variables at compile time.</p>
<p>The compiler can usually infer what type we want to use based on the value and how we use it. In cases when many types are possible, we must add a type annotation.</p>
<h3 id="321-scalar-types"><a class="header" href="#321-scalar-types">3.2.1 Scalar Types</a></h3>
<p><strong>Integer</strong></p>
<table><thead><tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td>i8</td><td>u8</td></tr>
<tr><td>16-bit</td><td>i16</td><td>u16</td></tr>
<tr><td>32-bit</td><td>i32</td><td>u32</td></tr>
<tr><td>64-bit</td><td>i64</td><td>u64</td></tr>
<tr><td>128-bit</td><td>i128</td><td>u128</td></tr>
<tr><td>arch</td><td>isize</td><td>usize</td></tr>
</tbody></table>
<p>Integer types <strong>default to i32</strong>.</p>
<p>Integer literal: for example, 1000. Number literals can also use _ as a visual separator to make the number easier to read, such as 1_000, which will have the same value as if you had specified 1000.</p>
<p><strong>Floating points</strong>: f32 and f64; the default type is f64 because on modern CPUs it's roughly the same speed as f32 but is capable of more precision.</p>
<p><strong>Boolean</strong> :true/false</p>
<p><strong>Character</strong>: four bytes in size and represents a Unicode Scalar Value, which means it can represent a lot more than just ASCII.</p>
<h3 id="322-compound-types"><a class="header" href="#322-compound-types">3.2.2 Compound Types</a></h3>
<p><strong>Tuple</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup: (i32, f64, u8) = (500, 6.4, 1);
<span class="boring">}
</span></code></pre></pre>
<p>Tuples have a fixed length: once declared, they cannot grow or shrink in size.</p>
<p>Destructure:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);
    let (x, y, z) = tup;
    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p><strong>Array</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
let a: [i32; 5] = [1, 2, 3, 4, 5];
let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<h2 id="33-functions"><a class="header" href="#33-functions">3.3. Functions</a></h2>
<h3 id="331-parameters"><a class="header" href="#331-parameters">3.3.1 Parameters</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<h3 id="332-statements-and-expressions"><a class="header" href="#332-statements-and-expressions">3.3.2 Statements and Expressions</a></h3>
<p>Function bodies are made up of a series of statements optionally ending in an expression.</p>
<p>Statements do not return values. Expressions evaluate to something.</p>
<p>Expressions do not include ending semicolons. If you add a semicolon to the end of an expression, you turn it into a statement, which will then not return a value.</p>
<h3 id="333-return-value"><a class="header" href="#333-return-value">3.3.3 Return Value</a></h3>
<p>Declare their type after an arrow (-&gt;).</p>
<p>In Rust, the return value of the function is synonymous with the value of the final expression in the block of the body of a function.</p>
<pre><pre class="playground"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<h2 id="34-comments"><a class="header" href="#34-comments">3.4. Comments</a></h2>
<p>In Rust, the idiomatic comment style starts a comment with two slashes <code>//</code>, and the comment continues until the end of the line. </p>
<p>Comments can also be placed at the end of lines containing code, but you’ll more often see them used with the comment on a separate line above the code it’s annotating.</p>
<p>For comments that extend beyond a single line, you’ll need to include <code>//</code> on each line.</p>
<h2 id="35-control-flow"><a class="header" href="#35-control-flow">3.5. Control Flow</a></h2>
<h3 id="351-if--else-if"><a class="header" href="#351-if--else-if">3.5.1 <code>if</code> / <code>else if</code></a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre></pre>
<h3 id="352-use-if-in-let-statement"><a class="header" href="#352-use-if-in-let-statement">3.5.2 Use <code>if</code> in <code>let</code> Statement</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre></pre>
<p>Both the if arm and the else arm should be the same type.</p>
<h3 id="353-loop-while"><a class="header" href="#353-loop-while">3.5.3 <code>loop</code>, <code>while</code></a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    loop {
        println!(&quot;again!&quot;);
    }
}
</code></pre></pre>
<p>Return Value from <code>loop</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;
    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2;
        }
    };
    println!(&quot;The result is {}&quot;, result);
}
</code></pre></pre>
<p>Conditional loop with <code>while</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;
    while number != 0 {
        println!(&quot;{}!&quot;, number);
        number -= 1;
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<h3 id="354-loop-through-a-collection"><a class="header" href="#354-loop-through-a-collection">3.5.4 Loop through a Collection</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    for element in a.iter() {
        println!(&quot;the value is: {}&quot;, element);
    }
}
</code></pre></pre>
<p>The use of <code>iter()</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{}!&quot;, number);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p><code>rev</code> to reverse the range.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-ownership"><a class="header" href="#4-ownership">4. Ownership</a></h1>
<p>All programs have to manage the way they use a computer's memory while running. Some languages have garbage collection; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: memory is managed through a system of <strong>ownership</strong> with a set of rules that the compiler checks at compile time. None of the ownership features slow down your program while it's running.</p>
<p>A word on GC: Garbage collection frees the programmer from manually deallocating memory. This eliminates or reduces some categories of errors: dangling pointers, double free bugs, certain kinds of memory leaks, etc. The disadvantages is that, it consumes computing resources in deciding which memory to free, even though the programmer may have already known this information.</p>
<h2 id="41-stack--heap"><a class="header" href="#41-stack--heap">4.1 Stack &amp; Heap</a></h2>
<p>All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead.</p>
<p>Pushing to the stack is faster than allocating on the heap. Accessing data in the heap is slower than accessing data on the stack. Allocating a large amount of space on the heap can also take time.</p>
<p>When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function's local variables get pushed onto the stack. When the function is over, those values get popped off the stack.</p>
<h2 id="42-ownership-rules"><a class="header" href="#42-ownership-rules">4.2 Ownership Rules</a></h2>
<p>Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you don't run out of space are all problems that ownership addresses. Once you understand ownership, you won't need to think about the stack and the heap very often, but knowing that managing heap data is why ownership exists can help explain why it works the way it does.</p>
<ul>
<li>Each value in Rust has a variable that's called its owner.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {                      // s is not valid here, it’s not yet declared
        let s = &quot;hello&quot;;   // s is valid from this point forward
        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
}
</code></pre></pre>
<h2 id="43-the-string-type-on-the-heap"><a class="header" href="#43-the-string-type-on-the-heap">4.3 The String Type (on the heap)</a></h2>
<p>The data types mentioned in Chapter 3 are all in the stack.</p>
<p>The <code>String</code> type is on the heap.</p>
<h2 id="44-move-and-clone"><a class="header" href="#44-move-and-clone">4.4 Move and Clone</a></h2>
<pre><code class="language-rust ignore">fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;                // s1 &quot;moved&quot; to s2, doesn't do &quot;deepcopy&quot;, but rather a shallow copy.
    println!(&quot;{}, world!&quot;, s1); // s1 can't be borrowed because it's already moved to s2
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1.clone();

    println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
}
</code></pre></pre>
<p><code>clone()</code> is like deepcopy.</p>
<p>For stack only data, no need to clone:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = x;  // clone; x isn't moved to y

    println!(&quot;x = {}, y = {}&quot;, x, y);  // x still available
}
</code></pre></pre>
<p>If a type implements the Copy trait, an older variable is still usable after assignment. Rust won’t let us annotate a type with the Copy trait if the type, or any of its parts, has implemented the Drop trait.</p>
<p>Any group of simple scalar values can implement <code>Copy</code>, and nothing that requires allocation or is some form of resource can implement Copy.</p>
<p>Here are some of the types that implement <code>Copy</code>:</p>
<ul>
<li>All the integer types, such as u32.</li>
<li>The Boolean type, bool, with values true and false.</li>
<li>All the floating point types, such as f64.</li>
<li>The character type, char.</li>
<li>Tuples, if they only contain types that also implement Copy. For example, (i32, i32) implements Copy, but (i32, String) does not.</li>
</ul>
<h2 id="45-functions-and-ownership"><a class="header" href="#45-functions-and-ownership">4.5 Functions and Ownership</a></h2>
<p>The semantics for passing a value to a function are similar to those for assigning a value to a variable. Passing a variable to a function will move or copy, just as assignment does.</p>
<p>Returning values can also transfer ownership. </p>
<h2 id="46-references-and-borrowing"><a class="header" href="#46-references-and-borrowing">4.6 References and Borrowing</a></h2>
<p><code>&amp;</code> and <code>*</code> (dereferencing), like in other languages.</p>
<p>Just as variables are immutable by default, so are references. We’re not allowed to modify something we have a reference to.</p>
<p><strong>Mutable reference:</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);
    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<p>Only one mutable reference to a particular piece of data in a particular scope. This code will fail:</p>
<pre><code class="language-rust ignore">fn main() {
    let mut s = String::from(&quot;hello&quot;);
    let r1 = &amp;mut s;
    let r2 = &amp;mut s;
    println!(&quot;{}, {}&quot;, r1, r2);
}
</code></pre>
<p>No combining mutable and immutable references.</p>
<h2 id="47-dangling-references"><a class="header" href="#47-dangling-references">4.7 Dangling References</a></h2>
<pre><code class="language-rust ignore">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String { // dangle returns a reference to a String

    let s = String::from(&quot;hello&quot;); // s is a new String

    &amp;s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
</code></pre>
<h2 id="48-rules-of-references"><a class="header" href="#48-rules-of-references">4.8 Rules of References</a></h2>
<ul>
<li>At any given time, you can have either one mutable reference or any number of immutable references.</li>
<li>References must always be valid.</li>
</ul>
<h2 id="49-the-slice-type"><a class="header" href="#49-the-slice-type">4.9 The Slice Type</a></h2>
<p>Slice also doesn't have ownership. Type: <code>&amp;str</code>.</p>
<p>We can create slices using a range within brackets by specifying [starting_index..ending_index].</p>
<p>With Rust’s .. range syntax, if you want to start at index zero, you can drop the value before the two periods. In other words, these are equal:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);

    let slice = &amp;s[0..2];
    let slice = &amp;s[0..=1];
    let slice = &amp;s[..2];
}
</code></pre></pre>
<p>You can also drop both values to take a slice of the entire string. So these are equal:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);
    let len = s.len();
    let slice = &amp;s[0..len];
    let slice = &amp;s[..];
}
</code></pre></pre>
<p><strong>String literals are slices.</strong></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
