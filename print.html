<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language Digest</a></li><li class="chapter-item expanded affix "><a href="0_introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="1_getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="2_guessing_game.html"><strong aria-hidden="true">2.</strong> Guessing Game</a></li><li class="chapter-item expanded "><a href="3_common_concepts.html"><strong aria-hidden="true">3.</strong> Common Concepts</a></li><li class="chapter-item expanded "><a href="4_ownership.html"><strong aria-hidden="true">4.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="5_structs.html"><strong aria-hidden="true">5.</strong> Structs</a></li><li class="chapter-item expanded "><a href="6_enums_and_pattern_matching.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-rust-programming-language"><a class="header" href="#the-rust-programming-language">The Rust Programming Language</a></h1>
<p>The digest for the <a href="https://doc.rust-lang.org/book/title-page.html">Rust book</a>.</p>
<p>For readers who don't have deep understanding of another programming language but want to learn Rust, it's highly recommended to read the original book. It's much more verbose but also much more in detail.</p>
<p>For experienced programmars who are already quite famliar with at least one language, reading this digest might work for you to get started with Rust quickly.</p>
<p>This digest also works as a &quot;cheat sheet&quot; if you forget something but want to do a quick search.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="0-introduction"><a class="header" href="#0-introduction">0. Introduction</a></h1>
<p>Rust usage examples:</p>
<ul>
<li>command line tools</li>
<li>web services</li>
<li>DevOps tooling</li>
<li>embedded devices</li>
<li>audio and video analysis and transcoding</li>
<li>cryptocurrencies</li>
<li>bioinformatics</li>
<li>search engines</li>
<li>Internet of Things applications</li>
<li>machine learning</li>
<li>major parts of the Firefox web browser.</li>
</ul>
<p>Rust is for people who crave <strong>speed and stability</strong> in a language. Speed: the speed of the programs that you can create with Rust and the speed at which Rust lets you write them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-getting-started"><a class="header" href="#1-getting-started">1. Getting Started</a></h1>
<h2 id="11-install"><a class="header" href="#11-install">1.1 Install</a></h2>
<p><code>rustup</code>: a command line tool for managing Rust versions and associated tools.</p>
<pre><code class="language-bash">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh

# A C compiler is required
# because some common Rust packages depend on C code and will need a C compiler.
# On macOS, you can get a C compiler by running:
xcode-select --install
</code></pre>
<p>Update:</p>
<pre><code class="language-bash">$ rustup update
</code></pre>
<p>Uninstall:</p>
<pre><code class="language-bash">rustup self uninstall
</code></pre>
<p>Version check:</p>
<pre><code class="language-bash">rustc --version
</code></pre>
<h2 id="12-write-compile-and-run"><a class="header" href="#12-write-compile-and-run">1.2 Write, Compile and Run</a></h2>
<pre><code class="language-bash">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
$ touch main.rs
</code></pre>
<p><strong>Rust files always end with the <em>.rs</em> extension. If you’re using more than one word in your filename, use an underscore to separate them. For example, use <em>hello_world.rs</em> rather than<em>helloworld.rs</em>.</strong></p>
<p>Now open the <em>main.rs</em> file you just created and enter the code in Listing 1-1.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<ul>
<li><code>fn</code></li>
<li>println! calls a Rust macro. If it called a function instead, it would be entered as println (without the !)</li>
<li>semicolon</li>
</ul>
<h2 id="13-cargo"><a class="header" href="#13-cargo">1.3 Cargo</a></h2>
<p>Check cargo's version:</p>
<pre><code class="language-bash">cargo --version
</code></pre>
<p>Create a project with cargo:</p>
<pre><code class="language-bash">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>Build and run:</p>
<pre><code class="language-bash">cargo build
cargo run
</code></pre>
<p>Cargo also provides a command called <strong>cargo check</strong>. This command quickly checks your code to make sure it compiles but doesn’t produce an executable:</p>
<pre><code class="language-bash">cargo check
</code></pre>
<p>When your project is finally ready for release, you can use <strong>cargo build --release</strong> to compile it with optimizations.</p>
<p>This command will create an executable in <code>target/release</code> instead of <code>target/debug</code>. The optimizations make your Rust code run faster, but turning them on lengthens the time it takes for your program to compile. This is why there are two different profiles: one for development, when you want to rebuild quickly and often, and another for building the final program you’ll give to a user that won’t be rebuilt repeatedly and that will run as fast as possible. <strong>If you're benchmarking your code's running time, be sure to run cargo build --release and benchmark with the executable in target/release.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-guessing-game"><a class="header" href="#2-guessing-game">2. Guessing Game</a></h1>
<h2 id="21-bring-library-into-scope"><a class="header" href="#21-bring-library-into-scope">2.1 Bring Library into Scope</a></h2>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<h2 id="22-mutable-vs-immutable"><a class="header" href="#22-mutable-vs-immutable">2.2 Mutable V.S. immutable</a></h2>
<pre><code class="language-rust ignore">let apples = 5; // immutable
let mut bananas = 5; // mutable
</code></pre>
<p>By default variables are immutable.</p>
<h2 id="23-read-input"><a class="header" href="#23-read-input">2.3 Read Input</a></h2>
<pre><code class="language-rust ignore">io::stdin()
    .read_line(&amp;mut guess)
    .expect(&quot;Failed to read line&quot;);
</code></pre>
<p>One long line is difficult to read, so it’s best to divide it.</p>
<p><code>read_line</code> returns a value, an <code>io::Result</code>. The Result types are enums. For Result, the variants are:</p>
<ul>
<li><code>Ok</code>: the operation was successful, and inside Ok is the successfully generated value;</li>
<li><code>Err</code>: the operation failed, and Err contains information about how or why the operation failed.</li>
</ul>
<p><code>expect</code>:</p>
<ul>
<li>if <code>io::Result</code> is an <code>Err</code> value, expect will cause the program to crash and display the message that you passed as an argument to expect;</li>
<li>if <code>io::Result</code> is an <code>Ok</code> value, expect will take the return value that Ok is holding and return just that value to you so you can use it.</li>
</ul>
<h2 id="24-line-print-with-placeholder"><a class="header" href="#24-line-print-with-placeholder">2.4 Line Print with Placeholder</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {} and y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<h2 id="25-adding-dependencies"><a class="header" href="#25-adding-dependencies">2.5 Adding Dependencies</a></h2>
<p>In <code>Cargo.toml</code> file, add:</p>
<pre><code class="language-rust ignore">rand = &quot;0.8.3&quot;
</code></pre>
<p>Here, SEMVER is used.</p>
<p>Update cargo:</p>
<pre><code class="language-bash">cargo update
</code></pre>
<h2 id="26-rng"><a class="header" href="#26-rng">2.6 RNG</a></h2>
<pre><code class="language-rust ignore">use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..101);
    println!(&quot;The secret number is: {}&quot;, secret_number);
}
</code></pre>
<h2 id="27-gen_range"><a class="header" href="#27-gen_range">2.7 <code>gen_range</code></a></h2>
<p>gen_range(start..end):</p>
<ul>
<li>inclusive on the lower bound</li>
<li>exclusive on the upper bound</li>
<li>range <code>1..101</code> is equivalent to <code>1..=100</code></li>
</ul>
<h2 id="28-match-expression"><a class="header" href="#28-match-expression">2.8 Match Expression</a></h2>
<p><code>std::cmp::Ordering</code> enum:</p>
<ul>
<li><code>Less</code></li>
<li><code>Greater</code></li>
<li><code>Equal</code></li>
</ul>
<p>A match expression is made up of arms:</p>
<pre><code class="language-rust ignore">match guess.cmp(&amp;secret_number) {
    Ordering::Less =&gt; println!(&quot;Too small!&quot;),
    Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
    Ordering::Equal =&gt; println!(&quot;You win!&quot;),
}
</code></pre>
<h2 id="29-trim--parse-handle-input"><a class="header" href="#29-trim--parse-handle-input">2.9 Trim &amp; Parse: Handle Input</a></h2>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</code></pre>
<p>The <code>trim</code> method eliminates <code>\n</code> or <code>\r\n</code>.</p>
<ul>
<li><code>parse</code> method on strings: parses a string into some kind of number</li>
<li>could easily cause an error</li>
<li>returns a <code>Result type</code>, needs to be handled</li>
</ul>
<h2 id="210-loop-and-break"><a class="header" href="#210-loop-and-break">2.10 Loop and Break</a></h2>
<pre><code class="language-rust ignore">    loop {
        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                break;
            }
        }
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-common-concepts"><a class="header" href="#3-common-concepts">3. Common Concepts</a></h1>
<h2 id="31-variables-and-mutability"><a class="header" href="#31-variables-and-mutability">3.1. Variables and Mutability</a></h2>
<h2 id="311-mutability"><a class="header" href="#311-mutability">3.1.1 Mutability</a></h2>
<p>By default, variables are immutable.</p>
<p>Error:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
}
</code></pre></pre>
<p>Make it mutable by adding mut in front of the variable name:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<h3 id="312-differences-between-variables-and-constants"><a class="header" href="#312-differences-between-variables-and-constants">3.1.2 Differences Between Variables and Constants</a></h3>
<ul>
<li>constants can't be mut</li>
<li>declaration: constants: <code>const</code> keyword</li>
<li>constants can be declared in any scope, including the global scope</li>
<li>constants may be set only to a constant expression, not the result of a function call or any other value that could only be computed at runtime</li>
</ul>
<p>Here’s an example of a constant declaration where the constant’s name is MAX_POINTS and its value is set to 100,000. (Rust’s naming convention for constants is to use all uppercase with underscores between words, and underscores can be inserted in numeric literals to improve readability):</p>
<h3 id="313-shadowing"><a class="header" href="#313-shadowing">3.1.3 Shadowing</a></h3>
<p>You can declare a new variable with the same name as a previous variable. The first variable is shadowed by the second.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let x = x + 1;
    let x = x * 2;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>Shadowing V.S. mut:</p>
<ul>
<li>reassign to this variable without using the let keyword will cause an error</li>
<li>we're effectively creating a new variable when we use the let keyword again, we can change the type of the value but reuse the same name. Mut can't change type.</li>
</ul>
<h2 id="32-data-types"><a class="header" href="#32-data-types">3.2. Data Types</a></h2>
<p>Rust is a statically typed language, which means that it must know the types of all variables at compile time.</p>
<p>The compiler can usually infer what type we want to use based on the value and how we use it. In cases when many types are possible, we must add a type annotation.</p>
<h3 id="321-scalar-types"><a class="header" href="#321-scalar-types">3.2.1 Scalar Types</a></h3>
<p><strong>Integer</strong></p>
<table><thead><tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td>i8</td><td>u8</td></tr>
<tr><td>16-bit</td><td>i16</td><td>u16</td></tr>
<tr><td>32-bit</td><td>i32</td><td>u32</td></tr>
<tr><td>64-bit</td><td>i64</td><td>u64</td></tr>
<tr><td>128-bit</td><td>i128</td><td>u128</td></tr>
<tr><td>arch</td><td>isize</td><td>usize</td></tr>
</tbody></table>
<p>Integer types <strong>default to i32</strong>.</p>
<p>Integer literal: for example, 1000. Number literals can also use _ as a visual separator to make the number easier to read, such as 1_000, which will have the same value as if you had specified 1000.</p>
<p><strong>Floating points</strong>: f32 and f64; the default type is f64 because on modern CPUs it's roughly the same speed as f32 but is capable of more precision.</p>
<p><strong>Boolean</strong> :true/false</p>
<p><strong>Character</strong>: four bytes in size and represents a Unicode Scalar Value, which means it can represent a lot more than just ASCII.</p>
<h3 id="322-compound-types"><a class="header" href="#322-compound-types">3.2.2 Compound Types</a></h3>
<p><strong>Tuple</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup: (i32, f64, u8) = (500, 6.4, 1);
<span class="boring">}
</span></code></pre></pre>
<p>Tuples have a fixed length: once declared, they cannot grow or shrink in size.</p>
<p>Destructure:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);
    let (x, y, z) = tup;
    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p><strong>Array</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
let a: [i32; 5] = [1, 2, 3, 4, 5];
let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<h2 id="33-functions"><a class="header" href="#33-functions">3.3. Functions</a></h2>
<h3 id="331-parameters"><a class="header" href="#331-parameters">3.3.1 Parameters</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<h3 id="332-statements-and-expressions"><a class="header" href="#332-statements-and-expressions">3.3.2 Statements and Expressions</a></h3>
<p>Function bodies are made up of a series of statements optionally ending in an expression.</p>
<p>Statements do not return values. Expressions evaluate to something.</p>
<p>Expressions do not include ending semicolons. If you add a semicolon to the end of an expression, you turn it into a statement, which will then not return a value.</p>
<h3 id="333-return-value"><a class="header" href="#333-return-value">3.3.3 Return Value</a></h3>
<p>Declare their type after an arrow (-&gt;).</p>
<p>In Rust, the return value of the function is synonymous with the value of the final expression in the block of the body of a function.</p>
<pre><pre class="playground"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<h2 id="34-comments"><a class="header" href="#34-comments">3.4. Comments</a></h2>
<p>In Rust, the idiomatic comment style starts a comment with two slashes <code>//</code>, and the comment continues until the end of the line. </p>
<p>Comments can also be placed at the end of lines containing code, but you’ll more often see them used with the comment on a separate line above the code it’s annotating.</p>
<p>For comments that extend beyond a single line, you’ll need to include <code>//</code> on each line.</p>
<h2 id="35-control-flow"><a class="header" href="#35-control-flow">3.5. Control Flow</a></h2>
<h3 id="351-if--else-if"><a class="header" href="#351-if--else-if">3.5.1 <code>if</code> / <code>else if</code></a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre></pre>
<h3 id="352-use-if-in-let-statement"><a class="header" href="#352-use-if-in-let-statement">3.5.2 Use <code>if</code> in <code>let</code> Statement</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre></pre>
<p>Both the if arm and the else arm should be the same type.</p>
<h3 id="353-loop-while"><a class="header" href="#353-loop-while">3.5.3 <code>loop</code>, <code>while</code></a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    loop {
        println!(&quot;again!&quot;);
    }
}
</code></pre></pre>
<p>Return Value from <code>loop</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;
    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2;
        }
    };
    println!(&quot;The result is {}&quot;, result);
}
</code></pre></pre>
<p>Conditional loop with <code>while</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;
    while number != 0 {
        println!(&quot;{}!&quot;, number);
        number -= 1;
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<h3 id="354-loop-through-a-collection"><a class="header" href="#354-loop-through-a-collection">3.5.4 Loop through a Collection</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    for element in a.iter() {
        println!(&quot;the value is: {}&quot;, element);
    }
}
</code></pre></pre>
<p>The use of <code>iter()</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{}!&quot;, number);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p><code>rev</code> to reverse the range.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-ownership"><a class="header" href="#4-ownership">4. Ownership</a></h1>
<p>All programs have to manage the way they use a computer's memory while running. Some languages have garbage collection; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: memory is managed through a system of <strong>ownership</strong> with a set of rules that the compiler checks at compile time. None of the ownership features slow down your program while it's running.</p>
<p>A word on GC: Garbage collection frees the programmer from manually deallocating memory. This eliminates or reduces some categories of errors: dangling pointers, double free bugs, certain kinds of memory leaks, etc. The disadvantages is that, it consumes computing resources in deciding which memory to free, even though the programmer may have already known this information.</p>
<h2 id="41-stack--heap"><a class="header" href="#41-stack--heap">4.1 Stack &amp; Heap</a></h2>
<p>All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead.</p>
<p>Pushing to the stack is faster than allocating on the heap. Accessing data in the heap is slower than accessing data on the stack. Allocating a large amount of space on the heap can also take time.</p>
<p>When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function's local variables get pushed onto the stack. When the function is over, those values get popped off the stack.</p>
<h2 id="42-ownership-rules"><a class="header" href="#42-ownership-rules">4.2 Ownership Rules</a></h2>
<p>Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you don't run out of space are all problems that ownership addresses. Once you understand ownership, you won't need to think about the stack and the heap very often, but knowing that managing heap data is why ownership exists can help explain why it works the way it does.</p>
<ul>
<li>Each value in Rust has a variable that's called its owner.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {                      // s is not valid here, it’s not yet declared
        let s = &quot;hello&quot;;   // s is valid from this point forward
        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
}
</code></pre></pre>
<h2 id="43-the-string-type-on-the-heap"><a class="header" href="#43-the-string-type-on-the-heap">4.3 The String Type (on the heap)</a></h2>
<p>The data types mentioned in Chapter 3 are all in the stack.</p>
<p>The <code>String</code> type is on the heap.</p>
<h2 id="44-move-and-clone"><a class="header" href="#44-move-and-clone">4.4 Move and Clone</a></h2>
<pre><code class="language-rust ignore">fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;                // s1 &quot;moved&quot; to s2, doesn't do &quot;deepcopy&quot;, but rather a shallow copy.
    println!(&quot;{}, world!&quot;, s1); // s1 can't be borrowed because it's already moved to s2
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1.clone();

    println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
}
</code></pre></pre>
<p><code>clone()</code> is like deepcopy.</p>
<p>For stack only data, no need to clone:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = x;  // clone; x isn't moved to y

    println!(&quot;x = {}, y = {}&quot;, x, y);  // x still available
}
</code></pre></pre>
<p>If a type implements the Copy trait, an older variable is still usable after assignment. Rust won’t let us annotate a type with the Copy trait if the type, or any of its parts, has implemented the Drop trait.</p>
<p>Any group of simple scalar values can implement <code>Copy</code>, and nothing that requires allocation or is some form of resource can implement Copy.</p>
<p>Here are some of the types that implement <code>Copy</code>:</p>
<ul>
<li>All the integer types, such as u32.</li>
<li>The Boolean type, bool, with values true and false.</li>
<li>All the floating point types, such as f64.</li>
<li>The character type, char.</li>
<li>Tuples, if they only contain types that also implement Copy. For example, (i32, i32) implements Copy, but (i32, String) does not.</li>
</ul>
<h2 id="45-functions-and-ownership"><a class="header" href="#45-functions-and-ownership">4.5 Functions and Ownership</a></h2>
<p>The semantics for passing a value to a function are similar to those for assigning a value to a variable. Passing a variable to a function will move or copy, just as assignment does.</p>
<p>Returning values can also transfer ownership. </p>
<h2 id="46-references-and-borrowing"><a class="header" href="#46-references-and-borrowing">4.6 References and Borrowing</a></h2>
<p><code>&amp;</code> and <code>*</code> (dereferencing), like in other languages.</p>
<p>Just as variables are immutable by default, so are references. We’re not allowed to modify something we have a reference to.</p>
<p><strong>Mutable reference:</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);
    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<p>Only one mutable reference to a particular piece of data in a particular scope. This code will fail:</p>
<pre><code class="language-rust ignore">fn main() {
    let mut s = String::from(&quot;hello&quot;);
    let r1 = &amp;mut s;
    let r2 = &amp;mut s;
    println!(&quot;{}, {}&quot;, r1, r2);
}
</code></pre>
<p>No combining mutable and immutable references.</p>
<h2 id="47-dangling-references"><a class="header" href="#47-dangling-references">4.7 Dangling References</a></h2>
<pre><code class="language-rust ignore">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String { // dangle returns a reference to a String

    let s = String::from(&quot;hello&quot;); // s is a new String

    &amp;s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
</code></pre>
<h2 id="48-rules-of-references"><a class="header" href="#48-rules-of-references">4.8 Rules of References</a></h2>
<ul>
<li>At any given time, you can have either one mutable reference or any number of immutable references.</li>
<li>References must always be valid.</li>
</ul>
<h2 id="49-the-slice-type"><a class="header" href="#49-the-slice-type">4.9 The Slice Type</a></h2>
<p>Slice also doesn't have ownership. Type: <code>&amp;str</code>.</p>
<p>We can create slices using a range within brackets by specifying [starting_index..ending_index].</p>
<p>With Rust’s .. range syntax, if you want to start at index zero, you can drop the value before the two periods. In other words, these are equal:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);

    let slice = &amp;s[0..2];
    let slice = &amp;s[0..=1];
    let slice = &amp;s[..2];
}
</code></pre></pre>
<p>You can also drop both values to take a slice of the entire string. So these are equal:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);
    let len = s.len();
    let slice = &amp;s[0..len];
    let slice = &amp;s[..];
}
</code></pre></pre>
<p><strong>String literals are slices.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-structs"><a class="header" href="#5-structs">5. Structs</a></h1>
<h2 id="51-mutable-struct"><a class="header" href="#51-mutable-struct">5.1 Mutable Struct:</a></h2>
<p><strong>The entire instance must be mutable; Rust doesn't allow us to mark only certain fields as mutable.</strong></p>
<h2 id="52-field-init-shorthand"><a class="header" href="#52-field-init-shorthand">5.2 Field Init Shorthand</a></h2>
<p>The main benefit of using methods instead of functions, in addition to using method syntax and not having to repeat the type of self in every method's signature, is for organization.</p>
<p>Use the same name as the fields:</p>
<pre><pre class="playground"><code class="language-rust">struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

fn build_user(email: String, username: String) -&gt; User {
    User {
        email,      // field init shorthand
        username,   // field init shorthand
        active: true,
        sign_in_count: 1,
    }
}

fn main() {
    let user1 = build_user(
        String::from(&quot;someone@example.com&quot;),
        String::from(&quot;someusername123&quot;),
    );
}
</code></pre></pre>
<p>The <code>String</code> type rather than the <code>&amp;str</code> string slice type is used in the example above.</p>
<p>This is a deliberate choice because we want instances of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.</p>
<h2 id="53-struct-update-syntax"><a class="header" href="#53-struct-update-syntax">5.3 Struct Update Syntax</a></h2>
<pre><code class="language-rust ignore">fn main() {
    let user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };

    let user2 = User {
        email: String::from(&quot;another@example.com&quot;),
        username: String::from(&quot;anotherusername567&quot;),
        ..user1     // struct update syntax
    };
}
</code></pre>
<h2 id="54-tuple-structs"><a class="header" href="#54-tuple-structs">5.4 Tuple Structs</a></h2>
<p>Tuple structs are useful when you want to give the whole tuple a name and make the tuple be a different type from other tuples, and naming each field as in a regular struct would be verbose or redundant.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);

    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
</code></pre></pre>
<h2 id="55-struct-as-param"><a class="header" href="#55-struct-as-param">5.5 Struct as param</a></h2>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}
</code></pre></pre>
<h2 id="56-adding-useful-functionality-with-derived-traits"><a class="header" href="#56-adding-useful-functionality-with-derived-traits">5.6 Adding Useful Functionality with Derived Traits</a></h2>
<p>In the <code>println!</code>, by default, the curly brackets tell <code>println!</code> to use formatting known as <code>Display</code>.</p>
<p>In format strings you may be able to use <code>{:?}</code> (or <code>{:#?}</code> for <strong>pretty-print</strong> instead, using the <code>Debug</code> trait.</p>
<p>We have to explicitly opt in to make that functionality available for our struct.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 is {:#?}&quot;, rect1);
}
</code></pre></pre>
<h2 id="57-method"><a class="header" href="#57-method">5.7 Method</a></h2>
<p>Methods are different from functions in that they're defined within the context of a struct, and their first parameter is always self, which represents the instance of the struct the method is being called on.</p>
<p>The main benefit of using methods instead of functions, in addition to using method syntax and not having to repeat the type of self in every method's signature, is for organization.</p>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        // here &amp;self is used instead of self,
        // beacuse we only want to read data, instead of taking ownership
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<p>The <code>impl</code> block defines on which struct the method is implemented.</p>
<p>Each struct is allowed to have multiple impl blocks.</p>
<p>Methods can take ownership of <code>self</code>, borrow self immutably (in the code above), or borrow self mutably.</p>
<p>If we wanted to change the instance that we've called the method on as part of what the method does, we'd use <code>&amp;mut self</code> as the first parameter.</p>
<h2 id="58-automatic-referencing-and-dereferencing"><a class="header" href="#58-automatic-referencing-and-dereferencing">5.8 Automatic Referencing and Dereferencing</a></h2>
<p>When you call a method with <code>object.something()</code>, Rust automatically adds in <code>&amp;</code>, <code>&amp;mut</code>, or <code>*</code> so object matches the signature of the method.</p>
<pre><code class="language-rust ignore">p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
</code></pre>
<p>They are the same.</p>
<h2 id="59-associated-functions"><a class="header" href="#59-associated-functions">5.9 Associated Functions</a></h2>
<p>Functions within impl blocks that don't take self as a parameter are called associated functions because they're associated with the struct.</p>
<p>They're still functions, not methods, because they don't have an instance of the struct to work with.</p>
<p>Associated functions are often used for constructors that will return a new instance of the struct. </p>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}

fn main() {
    let sq = Rectangle::square(3);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6-enums-and-pattern-matching"><a class="header" href="#6-enums-and-pattern-matching">6. Enums and Pattern Matching</a></h1>
<p>Enums (enumerations) allow you to define a type by enumerating its possible variants.</p>
<p>Enums are a feature in many languages, but their capabilities differ in each language.</p>
<p>Rust's enums are most similar to algebraic data types in functional languages, such as F#, OCaml, and Haskell.</p>
<h2 id="61-enum-definition--differences-with"><a class="header" href="#61-enum-definition--differences-with">6.1 Enum Definition &amp; Differences with</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    enum IpAddrKind {
        V4,
        V6,
    }

    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);
    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));

    enum Message {
        Quit,
        Move { x: i32, y: i32 },
        Write(String),
        ChangeColor(i32, i32, i32),
    }

    impl Message {
        fn call(&amp;self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from(&quot;hello&quot;));
    m.call();
}
</code></pre></pre>
<ul>
<li>We can attach data to each variant of the enum directly.</li>
<li>Each variant can have different types and amounts of associated data.</li>
<li>We can define methods on enums.</li>
</ul>
<h2 id="62-the-option-enum-vs-null-values"><a class="header" href="#62-the-option-enum-vs-null-values">6.2 The Option Enum V.S. Null Values</a></h2>
<p>Option is another enum defined by the standard library.</p>
<p>Null: billion-dollar mistake. Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum is Option<T>, and it is defined by the standard library as follows:</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
    enum Option&lt;T&gt; {
        None,
        Some(T),
    }
}
</code></pre></pre>
<p>The <code>Option&lt;T&gt;</code> enum is so useful that it's even included in the prelude; you don't need to bring it into scope explicitly. In addition, so are its variants: you can use <code>Some</code> and <code>None</code> directly without the <code>Option::</code> prefix. The <code>&lt;T&gt;</code> syntax: generic type parameter. <code>&lt;T&gt;</code> means the <code>Some</code> variant of the <code>Option</code> enum can hold one piece of data of any type. Here are some examples of using <code>Option</code> values to hold number types and string types:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_number = Some(5);
    let some_string = Some(&quot;a string&quot;);

    let absent_number: Option&lt;i32&gt; = None;
    // if we use None rather than Some,
    // we need to tell Rust what type of Option&lt;T&gt; we have
    // because the compiler can't infer the type,
    // that the `Some` variant will hold by looking only at a `None` value.
}
</code></pre></pre>
<p>When we have a <code>Some</code> value, we know that a value is present and the value is held within the <code>Some</code>. When we have a <code>None</code> value, in some sense, it means the same thing as null: we don't have a valid value. We can proceed confidently without having to check for null before using that value. You have to convert an <code>Option&lt;T&gt;</code> to a <code>T</code> before you can perform <code>T</code> operations with it. Generally, this helps catch one of the most common issues with null: assuming that something isn't null when it actually is.</p>
<h2 id="63-the-match-control-flow-operator"><a class="header" href="#63-the-match-control-flow-operator">6.3 The <code>match</code> Control Flow Operator</a></h2>
<pre><pre class="playground"><code class="language-rust">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
        // pattern =&gt; code
        // the =&gt; operator that separates the pattern and the code (expression) to run
        // arms are executed in order
    }
}

fn main() {}
</code></pre></pre>
<h2 id="64-patterns-that-bind-to-values"><a class="header" href="#64-patterns-that-bind-to-values">6.4 Patterns that Bind to Values</a></h2>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        }
    }
}

fn main() {
    value_in_cents(Coin::Quarter(UsState::Alaska));
}
</code></pre></pre>
<h2 id="65-matching-with-optiont"><a class="header" href="#65-matching-with-optiont">6.5 Matching with <code>Option&lt;T&gt;</code></a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
}
</code></pre></pre>
<p>Matches in Rust are exhaustive: we must exhaust every last possibility in order for the code to be valid.</p>
<h2 id="66-the-_-placeholder"><a class="header" href="#66-the-_-placeholder">6.6 The _ Placeholder</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_u8_value = 0u8;
    match some_u8_value {
        1 =&gt; println!(&quot;one&quot;),
        3 =&gt; println!(&quot;three&quot;),
        5 =&gt; println!(&quot;five&quot;),
        7 =&gt; println!(&quot;seven&quot;),
        _ =&gt; (),
        // () is the unit value
        // so nothing will happen in the _ case
    }
}
</code></pre></pre>
<p>The <code>_</code> pattern will match any value. By putting it after our other arms, the <code>_</code> will match all the possible cases that aren't specified before it.</p>
<h2 id="67-if-let-concise-control-flow"><a class="header" href="#67-if-let-concise-control-flow">6.7 <code>if let</code> Concise Control Flow</a></h2>
<p>The <code>if let</code> syntax lets you combine <code>if</code> and <code>let</code> into a less verbose way to handle values that match one pattern while ignoring the rest.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_u8_value = Some(0u8);
    match some_u8_value {
        Some(3) =&gt; println!(&quot;three&quot;),
        _ =&gt; (),
    }
}
</code></pre></pre>
<p>The following code behaves the same:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_u8_value = Some(0u8);
    if let Some(3) = some_u8_value {
        println!(&quot;three&quot;);
    }
}
</code></pre></pre>
<p>The syntax if let takes a pattern and an expression separated by an equal sign. It works the same way as a match, where the expression is given to the match and the pattern is its first arm.</p>
<p>Using if let means less typing, less indentation, and less boilerplate code. However, you lose the exhaustive checking that match enforces. Choosing between match and if let depends on what you’re doing in your particular situation and whether gaining conciseness is an appropriate trade-off for losing exhaustive checking.</p>
<p>In other words, you can think of if let as syntax sugar for a match that runs code when the value matches one pattern and then ignores all other values.</p>
<p>We can include an else with an if let.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn main() {
    let coin = Coin::Penny;
    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),
        _ =&gt; count += 1,
    }
}

</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn main() {
    let coin = Coin::Penny;
    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!(&quot;State quarter from {:?}!&quot;, state);
    } else {
        count += 1;
    }
}
</code></pre></pre>
<p>They are the same.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
